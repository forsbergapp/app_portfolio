



    
    <div class='section'>
        <div class='article'>
            <pre class="prettyprint source linenums"><code>/**
 * @module apps/common/src/functions/common_doc
*/
/**
 * @import { server_db_file_config_rest_api, server_server_res, serverDocumentType, serverDocumentMenu} from '../../../../server/types.js'
 */

/**
 * @name getFile
 * @description  Get file and add given suffix to path
 * @function
 * @param {string} path
 * @param {server_server_res} res
 * @returns {Promise.&lt;string>}
 */
const getFile = async (path, res) =>{
    /**@type{import('../../../../server/iam.js')} */
    const {iamUtilMesssageNotAuthorized} = await import(`file://${process.cwd()}/server/iam.js`);
    const fs = await import('node:fs');
    return fs.promises.readFile(path, 'utf8')
            .then(file=>file.toString())
            .catch(()=>{
                res.statusCode = 400;
                throw iamUtilMesssageNotAuthorized();
            });
};
/**
 * @name getFiles
 * @description Find all *.js files in given directory and its subdirectories
 * @function
 * @param {string} directory
 * @param {RegExp} filePattern
 * @returns {Promise.&lt;{id:number, file:string}[]>}
 */
const getFiles = async (directory, filePattern) =>{
    
    const fs = await import('node:fs');
    /**@type{{id:number, file:string}[]}*/
    const fileList = [];
    let index =0;
    /**
     * @param {string} directory
     * @param {RegExp} pattern
     * @returns {Promise.&lt;{id:number, file:string}[]>}
     */
    const findFiles = async (directory, pattern) =>{
        const files = await fs.promises.readdir(directory, { withFileTypes: true });
        
        for (const file of files){
            const fullPath = `${directory}/${file.name}`;
            if (file.isDirectory())
                await findFiles(fullPath, pattern);
            else 
                if (file.isFile() &amp;&amp; file.name.match(pattern)){
                    //remove OS path info, .js suffix and replace \\ with /                
                    fileList.push({   id: ++index,
                                        file:fullPath
                                            .replace(process.cwd(),'')
                                            .replace('.js','')
                                            .replaceAll('\\','/')});
                }
        }
        return fileList;
    };
    return await findFiles(directory, filePattern);
};
/**
 * @name getFileFunctions
 * @description
 * @function
 * @param {{app_id:Number,
 *          file:string,
 *          module:string,
 *          comment_with_filter:string|null}} parameters
 * @returns {Promise.&lt;string>}
 */
const getFileFunctions = async parameters =>{
    //replace variables for MODULE_APPS, MODULE_MICRSOERVICE and MODULE_SERVER

    //search all JSDoc comments
    const regexp_module_function = /\/\*\*([\s\S]*?)\*\//g;

    const module_functions =[];
    let match_module_function;

    // module table with variables
    const HEADER            = '|@{TYPE}         |@{FUNCTION_NAME}                       |';
    const ALIGNMENT         = '|:---------------|:--------------------------------------|';
    const FUNCTION_TAG      = '|@{FUNCTION_TAG} |@{FUNCTION_TEXT}                       |';
    const SOURCE_LINE_TAG   = '|Source line     |[@{MODULE_LINE}](@{SOURCE_LINE_LINK)   |';

    const REGEXP_TAG = /@\w+/g;

    
    parameters.file = parameters.file?.replaceAll('\r\n','\n') ??'';
    while ((match_module_function = regexp_module_function.exec(parameters.file ?? '')) !==null){
        //check if supported comment types and if filter should be used
        if (commentType(match_module_function[1]) &amp;&amp; match_module_function[1].indexOf(parameters.comment_with_filter ?? match_module_function[1])>-1){
            const function_tags = match_module_function[1].split('\n')
                    .map(row=>{
                                //reset regexp so regexp will work in loop
                                REGEXP_TAG.lastIndex = 0;
                                const tag = REGEXP_TAG.exec(row)?.[0]??'';
                                return FUNCTION_TAG
                                .replace(   '@{FUNCTION_TAG}',
                                            tag)
                                .replace(   '@{FUNCTION_TEXT}',
                                            //check if tag exists
                                            (tag!='' &amp;&amp; row.indexOf(tag)>-1)?
                                                //return part after tag
                                                HTMLEntities(row.substring(row
                                                                .indexOf(tag)+tag.length)
                                                                .trimStart()):
                                                    //no tag, return after first '*', remove start space characters
                                                    HTMLEntities(row
                                                        .substring(row.indexOf('*')+1)));
                                })
                                //remove @name tag (with one space so @namespace remains) presented in title
                                .filter(row=>row.indexOf('@name ')&lt;0)
                                //remove tags presented in title
                                .filter(row=>row.indexOf('@function')&lt;0)
                                .filter(row=>row.indexOf('@constant')&lt;0)
                                .filter(row=>row.indexOf('@class')&lt;0)
                                .join('\n');
            //calculate source line: row match found + match row length
            const source_line = (parameters.file?parameters.file.substring(0,parameters.file.indexOf(match_module_function[1])).split('\n').length:0)  + 
                match_module_function[1].split('\n').length;

            module_functions.push(
                                    HEADER
                                        .replace('@{TYPE}',commentType(match_module_function[1])??'')
                                        .replace('@{FUNCTION_NAME}',match_module_function[1].split('\n').filter(row=>row.indexOf('@name')>-1).length>0?
                                                                    match_module_function[1]
                                                                        .split('\n')
                                                                        .filter(row=>row.indexOf('@name')>-1)
                                                                        .map(row=>  row
                                                                                    .substring( row.indexOf('@name')+'@name'.length)
                                                                                    .trimStart())[0]:'')
                                    + '\n' +
                                    ALIGNMENT+ '\n' +
                                    function_tags + '\n' +
                                    SOURCE_LINE_TAG
                                        .replace('@{MODULE_LINE}',parameters.module ??'')
                                        .replace('@{SOURCE_LINE_LINK',`${parameters.module}#line${source_line}`));
        }
    }
    //replace all found JSDoc comments with markdown formatted module functions
    return module_functions.join('\n'+'\n');
};
/**
 * @name HTMLEntities
 * @description Return supported characters as HTML Entities for tables
 * @function
 * @param {string} text
 * @returns {string}
 */
const HTMLEntities = text => text
                            .replaceAll('|','&amp;vert;')
                            .replaceAll('[','&amp;#91;')
                            .replaceAll(']','&amp;#93;')
                            .replaceAll('&lt;','&amp;lt;')
                            .replaceAll('>','&amp;gt;');

/**
 * @name commentType
 * @description Returns type of comment or null if comment not supported
 * @function
 * @param {string} comment
 * @returns {string|null}
 */
const commentType = comment =>  comment.indexOf('@module')>-1?'Module':
                                comment.indexOf('@function')>-1?'Function':
                                comment.indexOf('@constant')>-1?'Constant':
                                comment.indexOf('@class')>-1?'Class':
                                comment.indexOf('@method')>-1?'Method':null;

/**
 * @name markdownRender
 * @description Renders markdown document from template APP
 * @function
 * @param {{app_id:number,
 *          type:serverDocumentType,
 *          doc:string,
 *          module:string,
 *          locale:string,
 *          res:server_server_res}} parameters
 * @returns {Promise.&lt;string>}
 */
const markdownRender = async parameters =>{
    /**@type{import('../../../../server/server.js')} */
    const {serverUtilNumberValue} = await import(`file://${process.cwd()}/server/server.js`);
    /**@type{import('../../../../server/db/fileModelApp.js')} */
    const fileModelApp = await import(`file://${process.cwd()}/server/db/fileModelApp.js`);
    

    switch (true){
        case parameters.type.toUpperCase()=='APP':{
            //replace variables for APP template
            /**@type{import('../../../../server/db/fileModelAppTranslation.js')} */
            const fileModelAppTranslation = await import(`file://${process.cwd()}/server/db/fileModelAppTranslation.js`);
            
            const app_translation = fileModelAppTranslation.get(parameters.app_id,null, parameters.locale, 
                                                                /**@ts-ignore */
                                                                serverUtilNumberValue(parameters.doc), null)[0];
            const app = fileModelApp.get({app_id:parameters.app_id, resource_id:serverUtilNumberValue(parameters.doc), res:null})[0];

            let markdown = await getFile(`${process.cwd()}/apps/common/src/functions/documentation/2.app.md`, parameters.res);
            //remove all '\r' in '\r\n'
            markdown = markdown.replaceAll('\r\n','\n');
            //replace APP_NAME
            markdown = markdown.replaceAll('@{APP_NAME}', app.name);
            //replace SCREENSHOT_START
            markdown = markdown.replaceAll('@{SCREENSHOT_START}', app_translation?app_translation.json_data.screenshot_start:'');
            //replace DESCRIPTION
            markdown = markdown.replaceAll('@{DESCRIPTION}', app_translation?app_translation.json_data.description:'');
            //replace REFERENCE
            markdown = markdown.replaceAll('@{REFERENCE}', app_translation?app_translation.json_data.reference:'');
            //replace TECHNOLOGY
            markdown = markdown.replaceAll('@{TECHNOLOGY}', app_translation?app_translation.json_data.technology:'');
            //replace SECURITY
            markdown = markdown.replaceAll('@{SECURITY}', app_translation?app_translation.json_data.security:'');
            //replace PATTERN
            markdown = markdown.replaceAll('@{PATTERN}', app_translation?app_translation.json_data.pattern:'');
            //replace SOLUTION
            markdown = markdown.replaceAll('@{SOLUTION}', app_translation?app_translation.json_data.solution:'');
            //replace SCREENSHOT_END
            //images are saved in an array
            return markdown.replaceAll('@{SCREENSHOT_END}', app_translation?app_translation.json_data.screenshot_end.join('\n'):'');
        }
        case parameters.type.toUpperCase().startsWith('MODULE'):{
            //replace variables for MODULE_APPS, MODULE_MICROSERVICE and MODULE_SERVER
            /**@type{import('../../../../server/db/fileModelAppParameter.js')} */
            const fileModelAppParameter = await import(`file://${process.cwd()}/server/db/fileModelAppParameter.js`);
            /**@type{import('../../../../server/db/fileModelConfig.js')} */
            const fileModelConfig = await import(`file://${process.cwd()}/server/db/fileModelConfig.js`);

            const markdown = await getFile(`${process.cwd()}/apps/common/src/functions/documentation/7.module.md`, parameters.res)
                        .then(markdown=>
                                markdown
                                .replaceAll('@{MODULE_NAME}',       parameters.module ?? '')
                                .replaceAll('@{MODULE}',            parameters.module ??'')
                                .replaceAll('@{SOURCE_LINK}',       parameters.module ??'')
                                //metadata tags                            
                                .replaceAll('@{SERVER_HOST}',       fileModelConfig.get('CONFIG_SERVER', 'SERVER', 'HOST')??'')
                                .replaceAll('@{APP_CONFIGURATION}', fileModelConfig.get('CONFIG_SERVER', 'METADATA', 'CONFIGURATION')??'')
                                .replaceAll('@{APP_COPYRIGHT}',     fileModelAppParameter.get({app_id:parameters.app_id, resource_id:parameters.app_id, res:null})[0].app_copyright.value??'')
                        );
            
            //replace all found JSDoc comments with markdown formatted module functions
            return markdown.replace('@{MODULE_FUNCTION}', 
                                    await getFileFunctions({app_id:         parameters.app_id,                                                 
                                                            file:           await getFile(`${process.cwd()}${parameters.doc}.js`, parameters.res),
                                                            module:         parameters.module,
                                                            comment_with_filter:null
                                                        }));
        }
        case parameters.type.toUpperCase()=='REST_API':{           
            if (parameters.doc=='6.restapi'){
                return await getFile(`${process.cwd()}/apps/common/src/functions/documentation/6.restapi.md`, parameters.res)
                            .then(markdown=>
                                    //remove all '\r' in '\r\n'
                                    markdown
                                    .replaceAll('\r\n','\n')
                                );
            }
            else{
                const filePattern = /\.js$/;
                /**@type{string[]} */
                const membersof = [];
                //Get REST API function with @namespace tag
                membersof.push(await getFileFunctions({ app_id:             parameters.app_id, 
                                                        file:               await getFile(`${process.cwd()}/server/server.js`, parameters.res),
                                                        module:             '/server/server',
                                                        comment_with_filter:'@namespace REST_API'
                                                    }));
                //Get all REST API functions with @memberof tag
                for (const directory of ['apps', 'microservice','server'])
                    for (const file of (await getFiles(`${process.cwd()}/${directory}`, filePattern)).map(row=>row.file)){
                        const file_functions = await getFileFunctions({ app_id:             parameters.app_id, 
                                                                        file:               await getFile(`${process.cwd()}${file}.js`, parameters.res),
                                                                        module:             file,
                                                                        comment_with_filter:'@memberof REST_API'
                                                                    });
                        if (file_functions != '')
                            membersof.push(file_functions);
                    }
                return await getFile(`${process.cwd()}/apps/common/src/functions/documentation/6.restapiFunctions.md`, parameters.res)
                    .then(markdown=>
                            //remove all '\r' in '\r\n'
                            markdown
                            .replaceAll('\r\n','\n')
                            .replace('@{REST_API_FUNCTIONS}',membersof.join('\n\n'))
                        );
            }
        }
        default:{
            return '';
        }
    }
};
/**
 * @name menuRender
 * @description Renders the menu with APP, REST_API, GUIDE and MODULE menu items
 * @function
 * @param {{app_id:number,
 *          res:server_server_res}} parameters
 * @returns {Promise.&lt;string>}
 */
const menuRender = async parameters =>{
    /**@type{import('../../../../server/db/fileModelApp.js')} */
    const fileModelApp = await import(`file://${process.cwd()}/server/db/fileModelApp.js`);

    /**@type{serverDocumentMenu[]} */
    const markdown_menu_docs = await getFile(`${process.cwd()}/apps/common/src/functions/documentation/menu.json`, parameters.res).then((/**@type{string}*/result)=>JSON.parse(result));
    for (const menu of markdown_menu_docs){
        switch (true){
            case menu.type=='APP':{
                //return menu for app with updated id and app name
                menu.menu_sub = fileModelApp.get({app_id:parameters.app_id, resource_id:null, res:null}).map(app=>{
                    return { 
                            id:app.id,
                            menu:app.name,
                            doc:app.id.toString()
                            };
                    });
                break;
            }
            case menu.type=='REST_API':
            case menu.type=='GUIDE':{
                //return menu with updated first title from the documents
                for (const menu_sub of menu.menu_sub??[]){
                    await getFile(`${process.cwd()}/apps/common/src/functions/documentation/${menu_sub.doc}.md`, parameters.res)
                            .then(result=>{
                                try {
                                    menu_sub.menu =  result.replaceAll('\r\n', '\n').split('\n').filter(row=>row.indexOf('#')==0)[0].split('#')[1];
                                } catch (error) {
                                    menu_sub.menu = '';
                                }
                            })
                            .catch(()=>menu_sub.menu = '');
                }
                break;
            }
            case menu.type.startsWith('MODULE'):{
                //return all *.js files in /apps, /microservices and /server directories
                const filePattern = /\.js$/;
                menu.menu_sub = (await getFiles(`${process.cwd()}/${menu.type.substring('MODULE'.length+1).toLowerCase()}`, filePattern))
                                .map(row=>{return {id:row.id, menu:row.file, doc:row.file};});
            }
        }
    }
    return JSON.stringify(markdown_menu_docs);
};
/**
 * @name appFunction
 * @description Get documentation menu, guide, app, module or jsdoc documentation
 * @function
 * @param {number} app_id
 * @param {{    type:serverDocumentType,
 *              data_app_id:number,
 *              doc:string}} data
 * @param {string} user_agent
 * @param {string} ip
 * @param {string} locale
 * @param {server_server_res} res
 * @returns {Promise.&lt;[string]>}
 */
const appFunction = async (app_id, data, user_agent, ip, locale, res) =>{
    /**@type{import('../../../../server/iam.js')} */
    const {iamUtilMesssageNotAuthorized} = await import(`file://${process.cwd()}/server/iam.js`);
    
    //check if valid document request
    if (
        ((data.type.toUpperCase()=='GUIDE' ||data.type.toUpperCase()=='APP'||data.type.toUpperCase()=='JSDOC') &amp;&amp; data?.doc == null) ||
        data?.doc &amp;&amp; (data.doc.indexOf('\\')>-1||data.doc.indexOf('..')>-1 ||data.doc.indexOf(' ')>-1)){
        res.statusCode = 400;
        throw iamUtilMesssageNotAuthorized();
    }
    else{
        switch (true){
            case data.type=='MENU':{
                return [await menuRender({app_id:app_id, res:res})];
            }
            case data.type=='MODULE_CODE' &amp;&amp; 
            (data.doc.startsWith('/apps') || data.doc.startsWith('/microservice')||data.doc.startsWith('/server')||data.doc.startsWith('/test')):{
                return [await getFile(`${process.cwd()}${data.doc}.js`, res)];
            }
            case data.type=='JSDOC':{
                return [await getFile(`${process.cwd()}/apps/common/src/jsdoc/${data.doc}`, res)];   
            }
            case data.type=='GUIDE':
            case data.type=='APP':
            case data.type=='REST_API':
            case data.type.startsWith('MODULE') &amp;&amp;
                (data.doc.startsWith('/apps') || data.doc.startsWith('/microservice')||data.doc.startsWith('/server')||data.doc.startsWith('/test')):{
                const {default:ComponentMarkdown} = await import('../component/common_markdown.js');
                const {default:ComponentOpenAPI} = await import('../component/common_openapi.js');
                /**@type{import('../../../../server/server.js')} */
                const {serverUtilNumberValue} = await import(`file://${process.cwd()}/server/server.js`);
                /**@type{import('../../../../server/db/fileModelConfig.js')} */
                const fileModelConfig = await import(`file://${process.cwd()}/server/db/fileModelConfig.js`);
                /**@type{import('../../../../server/db/fileModelApp.js')} */
                const fileModelApp = await import(`file://${process.cwd()}/server/db/fileModelApp.js`);
                //guide documents in separate files, app and modules use templates
                return [(await ComponentMarkdown({ data:{  
                                                        markdown: data.type.toUpperCase()=='GUIDE'?
                                                                    await getFile(`${process.cwd()}/apps/common/src/functions/documentation/${data.doc}.md`, res):
                                                                        await markdownRender({  app_id:app_id,
                                                                                                type:data.type,
                                                                                                doc:data.doc,
                                                                                                module:data.doc,
                                                                                                locale:locale,
                                                                                                res:res})},
                                                methods:null}))
                                        .replace(data.doc=='6.restapi'?'@{CONFIG_REST_API}':'',data.doc=='6.restapi'?
                                                await ComponentOpenAPI({data:   {  
                                                                                app_id: app_id
                                                                                },
                                                                        methods:{
                                                                                fileModelApp:fileModelApp,
                                                                                fileModelConfig:fileModelConfig,
                                                                                serverUtilNumberValue:serverUtilNumberValue
                                                                                }
                                                                        }):'')
                            ];
            }
            default:{
                res.statusCode = 400;
                throw iamUtilMesssageNotAuthorized();
            }
        }
    }
};
export default appFunction;</code></pre>
        </div>
    </div>



